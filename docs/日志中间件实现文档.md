# 日志中间件实现文档

## 功能概述

实现了一个全局日志中间件，用于记录所有 HTTP 请求的详细信息，包括请求方法、URL、IP 地址、响应状态码和响应时间。

## 实现步骤

### 第一步：创建日志中间件

**文件**: `src/common/middleware/logger.middleware.ts`

```typescript
import { Injectable, NestMiddleware, Logger } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  private readonly logger = new Logger(LoggerMiddleware.name);

  use(req: Request, res: Response, next: NextFunction) {
    const { method, originalUrl, ip } = req;
    const startTime = Date.now();

    // 记录请求开始
    this.logger.log(`${method} ${originalUrl} - ${ip}`);

    // 监听响应完成事件
    res.on('finish', () => {
      const { statusCode } = res;
      const responseTime = Date.now() - startTime;

      // 记录请求完成
      this.logger.log(
        `${method} ${originalUrl} ${statusCode} - ${responseTime}ms - ${ip}`,
      );
    });

    next();
  }
}
```

**核心功能**:
1. **记录请求开始**: 记录 HTTP 方法、URL 和 IP 地址
2. **计算响应时间**: 使用 `Date.now()` 计算请求处理时长
3. **监听响应完成**: 使用 `res.on('finish')` 监听响应完成事件
4. **记录请求完成**: 记录状态码和响应时间

### 第二步：注册中间件

**文件**: `src/app.module.ts`

```typescript
import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { LoggerMiddleware } from './common/middleware/logger.middleware';

@Module({
  imports: [
    // ... 其他导入
  ],
  controllers: [AppController],
  providers: [AppService, LoggerMiddleware],  // 注册为提供者
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggerMiddleware).forRoutes('*');  // 应用到所有路由
  }
}
```

**关键点**:
1. **实现 NestModule 接口**: 提供 `configure()` 方法
2. **注册为 Provider**: 在 `providers` 数组中添加中间件
3. **应用到所有路由**: 使用 `.forRoutes('*')` 匹配所有路由

## 日志输出示例

### 请求开始日志
```
[Nest] 92225  - 02/15/2026, 4:30:15 PM     LOG [LoggerMiddleware] GET /users - ::1
```

### 请求完成日志
```
[Nest] 92225  - 02/15/2026, 4:30:15 PM     LOG [LoggerMiddleware] GET /users 200 - 15ms - ::1
```

### 完整请求示例
```bash
# 发送请求
curl http://localhost:3000/users

# 日志输出
[LoggerMiddleware] GET /users - ::1
[LoggerMiddleware] GET /users 200 - 15ms - ::1
```

## 日志格式说明

### 请求开始格式
```
{method} {url} - {ip}
```

### 请求完成格式
```
{method} {url} {statusCode} - {responseTime}ms - {ip}
```

**字段说明**:
- `method`: HTTP 方法（GET、POST、PUT、DELETE 等）
- `url`: 请求的完整 URL 路径
- `statusCode`: HTTP 响应状态码（200、404、500 等）
- `responseTime`: 请求处理时间（毫秒）
- `ip`: 客户端 IP 地址

## 中间件特性

### 1. 全局应用
```typescript
consumer.apply(LoggerMiddleware).forRoutes('*');
```
- 匹配所有路由
- 包括静态资源、API 接口、Swagger 文档等

### 2. 精确计时
```typescript
const startTime = Date.now();
// ... 处理请求
const responseTime = Date.now() - startTime;
```
- 使用 `Date.now()` 获取高精度时间戳
- 计算从请求开始到响应完成的总时长

### 3. 异步监听
```typescript
res.on('finish', () => {
  // 响应完成后执行
});
```
- 使用事件监听器，不阻塞请求处理
- 确保在响应完全发送后才记录日志

## 高级用法

### 1. 排除特定路由

```typescript
configure(consumer: MiddlewareConsumer) {
  consumer
    .apply(LoggerMiddleware)
    .exclude(
      { path: 'health', method: RequestMethod.GET },  // 排除健康检查
      { path: 'api', method: RequestMethod.ALL },     // 排除 Swagger
    )
    .forRoutes('*');
}
```

### 2. 只应用到特定路由

```typescript
configure(consumer: MiddlewareConsumer) {
  consumer
    .apply(LoggerMiddleware)
    .forRoutes(
      { path: 'users', method: RequestMethod.ALL },
      { path: 'products', method: RequestMethod.ALL },
    );
}
```

### 3. 应用到特定控制器

```typescript
configure(consumer: MiddlewareConsumer) {
  consumer
    .apply(LoggerMiddleware)
    .forRoutes(UserController, ProductController);
}
```

## 与其他日志方案对比

### 1. 内置 Logger vs 自定义中间件

| 特性 | 内置 Logger | 自定义中间件 |
|------|-------------|--------------|
| 请求日志 | ❌ 不支持 | ✅ 支持 |
| 响应时间 | ❌ 不支持 | ✅ 支持 |
| 自定义格式 | ❌ 有限 | ✅ 完全自定义 |
| 性能开销 | 低 | 略高 |

### 2. 中间件 vs 拦截器（Interceptor）

| 特性 | 中间件 | 拦截器 |
|------|--------|--------|
| 执行时机 | 路由处理前 | 路由处理前后 |
| 访问响应数据 | ❌ 不支持 | ✅ 支持 |
| 修改响应 | ❌ 困难 | ✅ 容易 |
| 全局应用 | ✅ 容易 | ✅ 容易 |

### 3. 推荐使用场景

**使用中间件**:
- ✅ 记录请求日志
- ✅ 请求预处理
- ✅ 身份验证
- ✅ CORS 处理

**使用拦截器**:
- ✅ 修改响应数据
- ✅ 异常处理
- ✅ 缓存
- ✅ 超时处理

## 生产环境优化

### 1. 添加日志级别

```typescript
use(req: Request, res: Response, next: NextFunction) {
  const { method, originalUrl } = req;
  
  // 根据路径决定日志级别
  if (originalUrl.includes('/health')) {
    this.logger.debug(`${method} ${originalUrl}`);  // 健康检查用 debug
  } else {
    this.logger.log(`${method} ${originalUrl}`);    // 普通请求用 log
  }
  
  next();
}
```

### 2. 添加请求 ID

```typescript
use(req: Request, res: Response, next: NextFunction) {
  const requestId = Math.random().toString(36).substring(7);
  req['requestId'] = requestId;
  
  this.logger.log(`[${requestId}] ${method} ${originalUrl}`);
  
  res.on('finish', () => {
    this.logger.log(`[${requestId}] ${statusCode} - ${responseTime}ms`);
  });
  
  next();
}
```

### 3. 记录请求体（开发环境）

```typescript
use(req: Request, res: Response, next: NextFunction) {
  if (process.env.NODE_ENV === 'development') {
    this.logger.debug(`Request Body: ${JSON.stringify(req.body)}`);
  }
  next();
}
```

## 测试

### 1. 单元测试

```typescript
describe('LoggerMiddleware', () => {
  let middleware: LoggerMiddleware;
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let nextFunction: NextFunction;

  beforeEach(() => {
    middleware = new LoggerMiddleware();
    mockRequest = {
      method: 'GET',
      originalUrl: '/users',
      ip: '127.0.0.1',
    };
    mockResponse = {
      statusCode: 200,
      on: jest.fn((event, callback) => {
        if (event === 'finish') callback();
      }),
    };
    nextFunction = jest.fn();
  });

  it('should log request and response', () => {
    middleware.use(
      mockRequest as Request,
      mockResponse as Response,
      nextFunction,
    );
    
    expect(nextFunction).toHaveBeenCalled();
  });
});
```

### 2. 集成测试

```bash
# 启动应用
npm run start:dev

# 发送测试请求
curl http://localhost:3000/users
curl http://localhost:3000/users/1
curl -X POST http://localhost:3000/users -d '{"name":"test"}'

# 查看日志输出
```

## 故障排查

### 问题 1: 日志没有输出

**原因**: 中间件未正确注册

**解决**:
1. 检查 `providers` 数组是否包含 `LoggerMiddleware`
2. 检查 `configure()` 方法是否正确实现
3. 重启应用

### 问题 2: 响应时间不准确

**原因**: 使用了错误的事件监听器

**解决**:
```typescript
// ❌ 错误：使用 'end' 事件
res.on('end', () => { ... });

// ✅ 正确：使用 'finish' 事件
res.on('finish', () => { ... });
```

### 问题 3: 性能影响

**原因**: 日志记录过于频繁

**解决**:
1. 排除静态资源路由
2. 使用异步日志写入
3. 在生产环境降低日志级别

## 总结

✅ **已完成**:
1. 创建 `LoggerMiddleware` 中间件
2. 在 `AppModule` 中注册中间件
3. 应用到所有路由

✅ **功能特性**:
- 记录请求方法、URL、IP
- 计算响应时间
- 记录响应状态码
- 全局应用

✅ **生产就绪**:
- 性能开销小
- 易于扩展
- 支持自定义配置

**下一步建议**:
- 添加日志持久化（写入文件）
- 集成日志聚合服务（如 ELK）
- 添加请求 ID 追踪
- 实现日志轮转

---

**创建时间**: 2026-02-15  
**文档版本**: 1.0

